// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: metrics.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createMetricDefinition = `-- name: CreateMetricDefinition :one
INSERT INTO metric_definitions (tenant_id, name, display_name, description, unit, type, aggregation, alert_threshold)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
ON CONFLICT (tenant_id, name)
DO UPDATE SET
    display_name = EXCLUDED.display_name,
    description = EXCLUDED.description,
    unit = EXCLUDED.unit,
    type = EXCLUDED.type,
    aggregation = EXCLUDED.aggregation,
    alert_threshold = EXCLUDED.alert_threshold
RETURNING id, tenant_id, name, display_name, description, unit, type, aggregation, alert_threshold, created_at, updated_at
`

type CreateMetricDefinitionParams struct {
	TenantID       uuid.UUID `db:"tenant_id" json:"tenant_id"`
	Name           string    `db:"name" json:"name"`
	DisplayName    *string   `db:"display_name" json:"display_name"`
	Description    *string   `db:"description" json:"description"`
	Unit           *string   `db:"unit" json:"unit"`
	Type           string    `db:"type" json:"type"`
	Aggregation    *string   `db:"aggregation" json:"aggregation"`
	AlertThreshold []byte    `db:"alert_threshold" json:"alert_threshold"`
}

// Metric Definitions
func (q *Queries) CreateMetricDefinition(ctx context.Context, arg CreateMetricDefinitionParams) (MetricDefinition, error) {
	row := q.db.QueryRow(ctx, createMetricDefinition,
		arg.TenantID,
		arg.Name,
		arg.DisplayName,
		arg.Description,
		arg.Unit,
		arg.Type,
		arg.Aggregation,
		arg.AlertThreshold,
	)
	var i MetricDefinition
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.DisplayName,
		&i.Description,
		&i.Unit,
		&i.Type,
		&i.Aggregation,
		&i.AlertThreshold,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteMetricDefinition = `-- name: DeleteMetricDefinition :exec
DELETE FROM metric_definitions
WHERE tenant_id = $1 AND name = $2
`

type DeleteMetricDefinitionParams struct {
	TenantID uuid.UUID `db:"tenant_id" json:"tenant_id"`
	Name     string    `db:"name" json:"name"`
}

func (q *Queries) DeleteMetricDefinition(ctx context.Context, arg DeleteMetricDefinitionParams) error {
	_, err := q.db.Exec(ctx, deleteMetricDefinition, arg.TenantID, arg.Name)
	return err
}

const deleteOldMetrics = `-- name: DeleteOldMetrics :exec
DELETE FROM metrics
WHERE tenant_id = $1 AND timestamp < $2
`

type DeleteOldMetricsParams struct {
	TenantID  uuid.UUID `db:"tenant_id" json:"tenant_id"`
	Timestamp time.Time `db:"timestamp" json:"timestamp"`
}

func (q *Queries) DeleteOldMetrics(ctx context.Context, arg DeleteOldMetricsParams) error {
	_, err := q.db.Exec(ctx, deleteOldMetrics, arg.TenantID, arg.Timestamp)
	return err
}

const getLatestMetric = `-- name: GetLatestMetric :one
SELECT id, tenant_id, name, value, labels, source, timestamp, created_at FROM metrics
WHERE tenant_id = $1 AND name = $2
ORDER BY timestamp DESC
LIMIT 1
`

type GetLatestMetricParams struct {
	TenantID uuid.UUID `db:"tenant_id" json:"tenant_id"`
	Name     string    `db:"name" json:"name"`
}

func (q *Queries) GetLatestMetric(ctx context.Context, arg GetLatestMetricParams) (Metric, error) {
	row := q.db.QueryRow(ctx, getLatestMetric, arg.TenantID, arg.Name)
	var i Metric
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Value,
		&i.Labels,
		&i.Source,
		&i.Timestamp,
		&i.CreatedAt,
	)
	return i, err
}

const getMetricDefinition = `-- name: GetMetricDefinition :one
SELECT id, tenant_id, name, display_name, description, unit, type, aggregation, alert_threshold, created_at, updated_at FROM metric_definitions
WHERE tenant_id = $1 AND name = $2
`

type GetMetricDefinitionParams struct {
	TenantID uuid.UUID `db:"tenant_id" json:"tenant_id"`
	Name     string    `db:"name" json:"name"`
}

func (q *Queries) GetMetricDefinition(ctx context.Context, arg GetMetricDefinitionParams) (MetricDefinition, error) {
	row := q.db.QueryRow(ctx, getMetricDefinition, arg.TenantID, arg.Name)
	var i MetricDefinition
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.DisplayName,
		&i.Description,
		&i.Unit,
		&i.Type,
		&i.Aggregation,
		&i.AlertThreshold,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMetricNames = `-- name: GetMetricNames :many
SELECT DISTINCT name FROM metrics
WHERE tenant_id = $1
ORDER BY name
`

func (q *Queries) GetMetricNames(ctx context.Context, tenantID uuid.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, getMetricNames, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMetrics = `-- name: GetMetrics :many
SELECT id, tenant_id, name, value, labels, source, timestamp, created_at FROM metrics
WHERE tenant_id = $1
    AND name = $2
    AND timestamp >= $3
    AND timestamp <= $4
ORDER BY timestamp DESC
LIMIT $5
`

type GetMetricsParams struct {
	TenantID    uuid.UUID `db:"tenant_id" json:"tenant_id"`
	Name        string    `db:"name" json:"name"`
	Timestamp   time.Time `db:"timestamp" json:"timestamp"`
	Timestamp_2 time.Time `db:"timestamp_2" json:"timestamp_2"`
	Limit       int32     `db:"limit" json:"limit"`
}

func (q *Queries) GetMetrics(ctx context.Context, arg GetMetricsParams) ([]Metric, error) {
	rows, err := q.db.Query(ctx, getMetrics,
		arg.TenantID,
		arg.Name,
		arg.Timestamp,
		arg.Timestamp_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Metric{}
	for rows.Next() {
		var i Metric
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Value,
			&i.Labels,
			&i.Source,
			&i.Timestamp,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMetricsAggregate = `-- name: GetMetricsAggregate :one
SELECT
    COUNT(*) as count,
    AVG(value) as avg_value,
    MIN(value) as min_value,
    MAX(value) as max_value,
    SUM(value) as sum_value
FROM metrics
WHERE tenant_id = $1
    AND name = $2
    AND timestamp >= $3
    AND timestamp <= $4
`

type GetMetricsAggregateParams struct {
	TenantID    uuid.UUID `db:"tenant_id" json:"tenant_id"`
	Name        string    `db:"name" json:"name"`
	Timestamp   time.Time `db:"timestamp" json:"timestamp"`
	Timestamp_2 time.Time `db:"timestamp_2" json:"timestamp_2"`
}

type GetMetricsAggregateRow struct {
	Count    int64       `db:"count" json:"count"`
	AvgValue float64     `db:"avg_value" json:"avg_value"`
	MinValue interface{} `db:"min_value" json:"min_value"`
	MaxValue interface{} `db:"max_value" json:"max_value"`
	SumValue int64       `db:"sum_value" json:"sum_value"`
}

func (q *Queries) GetMetricsAggregate(ctx context.Context, arg GetMetricsAggregateParams) (GetMetricsAggregateRow, error) {
	row := q.db.QueryRow(ctx, getMetricsAggregate,
		arg.TenantID,
		arg.Name,
		arg.Timestamp,
		arg.Timestamp_2,
	)
	var i GetMetricsAggregateRow
	err := row.Scan(
		&i.Count,
		&i.AvgValue,
		&i.MinValue,
		&i.MaxValue,
		&i.SumValue,
	)
	return i, err
}

const getMetricsByLabels = `-- name: GetMetricsByLabels :many
SELECT id, tenant_id, name, value, labels, source, timestamp, created_at FROM metrics
WHERE tenant_id = $1
    AND name = $2
    AND labels @> $3
    AND timestamp >= $4
    AND timestamp <= $5
ORDER BY timestamp DESC
LIMIT $6
`

type GetMetricsByLabelsParams struct {
	TenantID    uuid.UUID `db:"tenant_id" json:"tenant_id"`
	Name        string    `db:"name" json:"name"`
	Labels      []byte    `db:"labels" json:"labels"`
	Timestamp   time.Time `db:"timestamp" json:"timestamp"`
	Timestamp_2 time.Time `db:"timestamp_2" json:"timestamp_2"`
	Limit       int32     `db:"limit" json:"limit"`
}

func (q *Queries) GetMetricsByLabels(ctx context.Context, arg GetMetricsByLabelsParams) ([]Metric, error) {
	rows, err := q.db.Query(ctx, getMetricsByLabels,
		arg.TenantID,
		arg.Name,
		arg.Labels,
		arg.Timestamp,
		arg.Timestamp_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Metric{}
	for rows.Next() {
		var i Metric
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Value,
			&i.Labels,
			&i.Source,
			&i.Timestamp,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertMetric = `-- name: InsertMetric :one
INSERT INTO metrics (tenant_id, name, value, labels, source, timestamp)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, tenant_id, name, value, labels, source, timestamp, created_at
`

type InsertMetricParams struct {
	TenantID  uuid.UUID `db:"tenant_id" json:"tenant_id"`
	Name      string    `db:"name" json:"name"`
	Value     float64   `db:"value" json:"value"`
	Labels    []byte    `db:"labels" json:"labels"`
	Source    *string   `db:"source" json:"source"`
	Timestamp time.Time `db:"timestamp" json:"timestamp"`
}

func (q *Queries) InsertMetric(ctx context.Context, arg InsertMetricParams) (Metric, error) {
	row := q.db.QueryRow(ctx, insertMetric,
		arg.TenantID,
		arg.Name,
		arg.Value,
		arg.Labels,
		arg.Source,
		arg.Timestamp,
	)
	var i Metric
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Value,
		&i.Labels,
		&i.Source,
		&i.Timestamp,
		&i.CreatedAt,
	)
	return i, err
}

type InsertMetricsBatchParams struct {
	TenantID  uuid.UUID `db:"tenant_id" json:"tenant_id"`
	Name      string    `db:"name" json:"name"`
	Value     float64   `db:"value" json:"value"`
	Labels    []byte    `db:"labels" json:"labels"`
	Source    *string   `db:"source" json:"source"`
	Timestamp time.Time `db:"timestamp" json:"timestamp"`
}

const listMetricDefinitions = `-- name: ListMetricDefinitions :many
SELECT id, tenant_id, name, display_name, description, unit, type, aggregation, alert_threshold, created_at, updated_at FROM metric_definitions
WHERE tenant_id = $1
ORDER BY name
`

func (q *Queries) ListMetricDefinitions(ctx context.Context, tenantID uuid.UUID) ([]MetricDefinition, error) {
	rows, err := q.db.Query(ctx, listMetricDefinitions, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MetricDefinition{}
	for rows.Next() {
		var i MetricDefinition
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.DisplayName,
			&i.Description,
			&i.Unit,
			&i.Type,
			&i.Aggregation,
			&i.AlertThreshold,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
