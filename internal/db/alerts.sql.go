// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: alerts.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const acknowledgeAlert = `-- name: AcknowledgeAlert :one
UPDATE alerts
SET status = 'acknowledged', acknowledged_at = NOW(), acknowledged_by = $2
WHERE id = $1
RETURNING id, tenant_id, workflow_id, execution_id, severity, title, message, status, acknowledged_at, acknowledged_by, resolved_at, resolved_by, created_at
`

type AcknowledgeAlertParams struct {
	ID             uuid.UUID   `db:"id" json:"id"`
	AcknowledgedBy pgtype.UUID `db:"acknowledged_by" json:"acknowledged_by"`
}

func (q *Queries) AcknowledgeAlert(ctx context.Context, arg AcknowledgeAlertParams) (Alert, error) {
	row := q.db.QueryRow(ctx, acknowledgeAlert, arg.ID, arg.AcknowledgedBy)
	var i Alert
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.WorkflowID,
		&i.ExecutionID,
		&i.Severity,
		&i.Title,
		&i.Message,
		&i.Status,
		&i.AcknowledgedAt,
		&i.AcknowledgedBy,
		&i.ResolvedAt,
		&i.ResolvedBy,
		&i.CreatedAt,
	)
	return i, err
}

const countAlerts = `-- name: CountAlerts :one
SELECT COUNT(*) FROM alerts WHERE tenant_id = $1
`

func (q *Queries) CountAlerts(ctx context.Context, tenantID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countAlerts, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAlertsByStatus = `-- name: CountAlertsByStatus :one
SELECT COUNT(*) FROM alerts WHERE tenant_id = $1 AND status = $2
`

type CountAlertsByStatusParams struct {
	TenantID uuid.UUID `db:"tenant_id" json:"tenant_id"`
	Status   string    `db:"status" json:"status"`
}

func (q *Queries) CountAlertsByStatus(ctx context.Context, arg CountAlertsByStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAlertsByStatus, arg.TenantID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOpenAlertsBySeverity = `-- name: CountOpenAlertsBySeverity :many
SELECT severity, COUNT(*) as count
FROM alerts
WHERE tenant_id = $1 AND status = 'open'
GROUP BY severity
`

type CountOpenAlertsBySeverityRow struct {
	Severity string `db:"severity" json:"severity"`
	Count    int64  `db:"count" json:"count"`
}

func (q *Queries) CountOpenAlertsBySeverity(ctx context.Context, tenantID uuid.UUID) ([]CountOpenAlertsBySeverityRow, error) {
	rows, err := q.db.Query(ctx, countOpenAlertsBySeverity, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountOpenAlertsBySeverityRow{}
	for rows.Next() {
		var i CountOpenAlertsBySeverityRow
		if err := rows.Scan(&i.Severity, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createAlert = `-- name: CreateAlert :one
INSERT INTO alerts (tenant_id, workflow_id, execution_id, severity, title, message, status)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, tenant_id, workflow_id, execution_id, severity, title, message, status, acknowledged_at, acknowledged_by, resolved_at, resolved_by, created_at
`

type CreateAlertParams struct {
	TenantID    uuid.UUID   `db:"tenant_id" json:"tenant_id"`
	WorkflowID  pgtype.UUID `db:"workflow_id" json:"workflow_id"`
	ExecutionID pgtype.UUID `db:"execution_id" json:"execution_id"`
	Severity    string      `db:"severity" json:"severity"`
	Title       string      `db:"title" json:"title"`
	Message     *string     `db:"message" json:"message"`
	Status      string      `db:"status" json:"status"`
}

func (q *Queries) CreateAlert(ctx context.Context, arg CreateAlertParams) (Alert, error) {
	row := q.db.QueryRow(ctx, createAlert,
		arg.TenantID,
		arg.WorkflowID,
		arg.ExecutionID,
		arg.Severity,
		arg.Title,
		arg.Message,
		arg.Status,
	)
	var i Alert
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.WorkflowID,
		&i.ExecutionID,
		&i.Severity,
		&i.Title,
		&i.Message,
		&i.Status,
		&i.AcknowledgedAt,
		&i.AcknowledgedBy,
		&i.ResolvedAt,
		&i.ResolvedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getAlert = `-- name: GetAlert :one
SELECT id, tenant_id, workflow_id, execution_id, severity, title, message, status, acknowledged_at, acknowledged_by, resolved_at, resolved_by, created_at FROM alerts WHERE id = $1
`

func (q *Queries) GetAlert(ctx context.Context, id uuid.UUID) (Alert, error) {
	row := q.db.QueryRow(ctx, getAlert, id)
	var i Alert
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.WorkflowID,
		&i.ExecutionID,
		&i.Severity,
		&i.Title,
		&i.Message,
		&i.Status,
		&i.AcknowledgedAt,
		&i.AcknowledgedBy,
		&i.ResolvedAt,
		&i.ResolvedBy,
		&i.CreatedAt,
	)
	return i, err
}

const listAlerts = `-- name: ListAlerts :many
SELECT id, tenant_id, workflow_id, execution_id, severity, title, message, status, acknowledged_at, acknowledged_by, resolved_at, resolved_by, created_at FROM alerts
WHERE tenant_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListAlertsParams struct {
	TenantID uuid.UUID `db:"tenant_id" json:"tenant_id"`
	Limit    int32     `db:"limit" json:"limit"`
	Offset   int32     `db:"offset" json:"offset"`
}

func (q *Queries) ListAlerts(ctx context.Context, arg ListAlertsParams) ([]Alert, error) {
	rows, err := q.db.Query(ctx, listAlerts, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Alert{}
	for rows.Next() {
		var i Alert
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.WorkflowID,
			&i.ExecutionID,
			&i.Severity,
			&i.Title,
			&i.Message,
			&i.Status,
			&i.AcknowledgedAt,
			&i.AcknowledgedBy,
			&i.ResolvedAt,
			&i.ResolvedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAlertsBySeverity = `-- name: ListAlertsBySeverity :many
SELECT id, tenant_id, workflow_id, execution_id, severity, title, message, status, acknowledged_at, acknowledged_by, resolved_at, resolved_by, created_at FROM alerts
WHERE tenant_id = $1 AND severity = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListAlertsBySeverityParams struct {
	TenantID uuid.UUID `db:"tenant_id" json:"tenant_id"`
	Severity string    `db:"severity" json:"severity"`
	Limit    int32     `db:"limit" json:"limit"`
	Offset   int32     `db:"offset" json:"offset"`
}

func (q *Queries) ListAlertsBySeverity(ctx context.Context, arg ListAlertsBySeverityParams) ([]Alert, error) {
	rows, err := q.db.Query(ctx, listAlertsBySeverity,
		arg.TenantID,
		arg.Severity,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Alert{}
	for rows.Next() {
		var i Alert
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.WorkflowID,
			&i.ExecutionID,
			&i.Severity,
			&i.Title,
			&i.Message,
			&i.Status,
			&i.AcknowledgedAt,
			&i.AcknowledgedBy,
			&i.ResolvedAt,
			&i.ResolvedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAlertsByStatus = `-- name: ListAlertsByStatus :many
SELECT id, tenant_id, workflow_id, execution_id, severity, title, message, status, acknowledged_at, acknowledged_by, resolved_at, resolved_by, created_at FROM alerts
WHERE tenant_id = $1 AND status = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListAlertsByStatusParams struct {
	TenantID uuid.UUID `db:"tenant_id" json:"tenant_id"`
	Status   string    `db:"status" json:"status"`
	Limit    int32     `db:"limit" json:"limit"`
	Offset   int32     `db:"offset" json:"offset"`
}

func (q *Queries) ListAlertsByStatus(ctx context.Context, arg ListAlertsByStatusParams) ([]Alert, error) {
	rows, err := q.db.Query(ctx, listAlertsByStatus,
		arg.TenantID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Alert{}
	for rows.Next() {
		var i Alert
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.WorkflowID,
			&i.ExecutionID,
			&i.Severity,
			&i.Title,
			&i.Message,
			&i.Status,
			&i.AcknowledgedAt,
			&i.AcknowledgedBy,
			&i.ResolvedAt,
			&i.ResolvedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOpenAlerts = `-- name: ListOpenAlerts :many
SELECT id, tenant_id, workflow_id, execution_id, severity, title, message, status, acknowledged_at, acknowledged_by, resolved_at, resolved_by, created_at FROM alerts
WHERE tenant_id = $1 AND status = 'open'
ORDER BY
    CASE severity
        WHEN 'critical' THEN 1
        WHEN 'warning' THEN 2
        WHEN 'info' THEN 3
    END,
    created_at DESC
LIMIT $2 OFFSET $3
`

type ListOpenAlertsParams struct {
	TenantID uuid.UUID `db:"tenant_id" json:"tenant_id"`
	Limit    int32     `db:"limit" json:"limit"`
	Offset   int32     `db:"offset" json:"offset"`
}

func (q *Queries) ListOpenAlerts(ctx context.Context, arg ListOpenAlertsParams) ([]Alert, error) {
	rows, err := q.db.Query(ctx, listOpenAlerts, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Alert{}
	for rows.Next() {
		var i Alert
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.WorkflowID,
			&i.ExecutionID,
			&i.Severity,
			&i.Title,
			&i.Message,
			&i.Status,
			&i.AcknowledgedAt,
			&i.AcknowledgedBy,
			&i.ResolvedAt,
			&i.ResolvedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resolveAlert = `-- name: ResolveAlert :one
UPDATE alerts
SET status = 'resolved', resolved_at = NOW(), resolved_by = $2
WHERE id = $1
RETURNING id, tenant_id, workflow_id, execution_id, severity, title, message, status, acknowledged_at, acknowledged_by, resolved_at, resolved_by, created_at
`

type ResolveAlertParams struct {
	ID         uuid.UUID   `db:"id" json:"id"`
	ResolvedBy pgtype.UUID `db:"resolved_by" json:"resolved_by"`
}

func (q *Queries) ResolveAlert(ctx context.Context, arg ResolveAlertParams) (Alert, error) {
	row := q.db.QueryRow(ctx, resolveAlert, arg.ID, arg.ResolvedBy)
	var i Alert
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.WorkflowID,
		&i.ExecutionID,
		&i.Severity,
		&i.Title,
		&i.Message,
		&i.Status,
		&i.AcknowledgedAt,
		&i.AcknowledgedBy,
		&i.ResolvedAt,
		&i.ResolvedBy,
		&i.CreatedAt,
	)
	return i, err
}
