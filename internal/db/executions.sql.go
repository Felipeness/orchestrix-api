// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: executions.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const completeExecution = `-- name: CompleteExecution :one
UPDATE executions
SET status = $2, output = $3, completed_at = NOW()
WHERE id = $1
RETURNING id, tenant_id, workflow_id, temporal_workflow_id, temporal_run_id, status, input, output, error, started_at, completed_at, created_by, created_at
`

type CompleteExecutionParams struct {
	ID     uuid.UUID `db:"id" json:"id"`
	Status string    `db:"status" json:"status"`
	Output []byte    `db:"output" json:"output"`
}

func (q *Queries) CompleteExecution(ctx context.Context, arg CompleteExecutionParams) (Execution, error) {
	row := q.db.QueryRow(ctx, completeExecution, arg.ID, arg.Status, arg.Output)
	var i Execution
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.WorkflowID,
		&i.TemporalWorkflowID,
		&i.TemporalRunID,
		&i.Status,
		&i.Input,
		&i.Output,
		&i.Error,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const countExecutions = `-- name: CountExecutions :one
SELECT COUNT(*) FROM executions WHERE tenant_id = $1
`

func (q *Queries) CountExecutions(ctx context.Context, tenantID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countExecutions, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countExecutionsByStatus = `-- name: CountExecutionsByStatus :one
SELECT COUNT(*) FROM executions WHERE tenant_id = $1 AND status = $2
`

type CountExecutionsByStatusParams struct {
	TenantID uuid.UUID `db:"tenant_id" json:"tenant_id"`
	Status   string    `db:"status" json:"status"`
}

func (q *Queries) CountExecutionsByStatus(ctx context.Context, arg CountExecutionsByStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, countExecutionsByStatus, arg.TenantID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createExecution = `-- name: CreateExecution :one
INSERT INTO executions (tenant_id, workflow_id, temporal_workflow_id, temporal_run_id, status, input, created_by)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, tenant_id, workflow_id, temporal_workflow_id, temporal_run_id, status, input, output, error, started_at, completed_at, created_by, created_at
`

type CreateExecutionParams struct {
	TenantID           uuid.UUID   `db:"tenant_id" json:"tenant_id"`
	WorkflowID         uuid.UUID   `db:"workflow_id" json:"workflow_id"`
	TemporalWorkflowID *string     `db:"temporal_workflow_id" json:"temporal_workflow_id"`
	TemporalRunID      *string     `db:"temporal_run_id" json:"temporal_run_id"`
	Status             string      `db:"status" json:"status"`
	Input              []byte      `db:"input" json:"input"`
	CreatedBy          pgtype.UUID `db:"created_by" json:"created_by"`
}

func (q *Queries) CreateExecution(ctx context.Context, arg CreateExecutionParams) (Execution, error) {
	row := q.db.QueryRow(ctx, createExecution,
		arg.TenantID,
		arg.WorkflowID,
		arg.TemporalWorkflowID,
		arg.TemporalRunID,
		arg.Status,
		arg.Input,
		arg.CreatedBy,
	)
	var i Execution
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.WorkflowID,
		&i.TemporalWorkflowID,
		&i.TemporalRunID,
		&i.Status,
		&i.Input,
		&i.Output,
		&i.Error,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const failExecution = `-- name: FailExecution :one
UPDATE executions
SET status = 'failed', error = $2, completed_at = NOW()
WHERE id = $1
RETURNING id, tenant_id, workflow_id, temporal_workflow_id, temporal_run_id, status, input, output, error, started_at, completed_at, created_by, created_at
`

type FailExecutionParams struct {
	ID    uuid.UUID `db:"id" json:"id"`
	Error *string   `db:"error" json:"error"`
}

func (q *Queries) FailExecution(ctx context.Context, arg FailExecutionParams) (Execution, error) {
	row := q.db.QueryRow(ctx, failExecution, arg.ID, arg.Error)
	var i Execution
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.WorkflowID,
		&i.TemporalWorkflowID,
		&i.TemporalRunID,
		&i.Status,
		&i.Input,
		&i.Output,
		&i.Error,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getExecution = `-- name: GetExecution :one
SELECT id, tenant_id, workflow_id, temporal_workflow_id, temporal_run_id, status, input, output, error, started_at, completed_at, created_by, created_at FROM executions WHERE id = $1
`

func (q *Queries) GetExecution(ctx context.Context, id uuid.UUID) (Execution, error) {
	row := q.db.QueryRow(ctx, getExecution, id)
	var i Execution
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.WorkflowID,
		&i.TemporalWorkflowID,
		&i.TemporalRunID,
		&i.Status,
		&i.Input,
		&i.Output,
		&i.Error,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getExecutionByTemporalID = `-- name: GetExecutionByTemporalID :one
SELECT id, tenant_id, workflow_id, temporal_workflow_id, temporal_run_id, status, input, output, error, started_at, completed_at, created_by, created_at FROM executions WHERE temporal_workflow_id = $1
`

func (q *Queries) GetExecutionByTemporalID(ctx context.Context, temporalWorkflowID *string) (Execution, error) {
	row := q.db.QueryRow(ctx, getExecutionByTemporalID, temporalWorkflowID)
	var i Execution
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.WorkflowID,
		&i.TemporalWorkflowID,
		&i.TemporalRunID,
		&i.Status,
		&i.Input,
		&i.Output,
		&i.Error,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getExecutionStats = `-- name: GetExecutionStats :one
SELECT
    COUNT(*) as total,
    COUNT(*) FILTER (WHERE status = 'completed') as completed,
    COUNT(*) FILTER (WHERE status = 'failed') as failed,
    COUNT(*) FILTER (WHERE status = 'running') as running,
    COUNT(*) FILTER (WHERE status = 'pending') as pending,
    AVG(EXTRACT(EPOCH FROM (completed_at - started_at))) FILTER (WHERE completed_at IS NOT NULL) as avg_duration_seconds
FROM executions
WHERE tenant_id = $1 AND created_at > $2
`

type GetExecutionStatsParams struct {
	TenantID  uuid.UUID `db:"tenant_id" json:"tenant_id"`
	CreatedAt time.Time `db:"created_at" json:"created_at"`
}

type GetExecutionStatsRow struct {
	Total              int64   `db:"total" json:"total"`
	Completed          int64   `db:"completed" json:"completed"`
	Failed             int64   `db:"failed" json:"failed"`
	Running            int64   `db:"running" json:"running"`
	Pending            int64   `db:"pending" json:"pending"`
	AvgDurationSeconds float64 `db:"avg_duration_seconds" json:"avg_duration_seconds"`
}

func (q *Queries) GetExecutionStats(ctx context.Context, arg GetExecutionStatsParams) (GetExecutionStatsRow, error) {
	row := q.db.QueryRow(ctx, getExecutionStats, arg.TenantID, arg.CreatedAt)
	var i GetExecutionStatsRow
	err := row.Scan(
		&i.Total,
		&i.Completed,
		&i.Failed,
		&i.Running,
		&i.Pending,
		&i.AvgDurationSeconds,
	)
	return i, err
}

const listExecutions = `-- name: ListExecutions :many
SELECT id, tenant_id, workflow_id, temporal_workflow_id, temporal_run_id, status, input, output, error, started_at, completed_at, created_by, created_at FROM executions
WHERE tenant_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListExecutionsParams struct {
	TenantID uuid.UUID `db:"tenant_id" json:"tenant_id"`
	Limit    int32     `db:"limit" json:"limit"`
	Offset   int32     `db:"offset" json:"offset"`
}

func (q *Queries) ListExecutions(ctx context.Context, arg ListExecutionsParams) ([]Execution, error) {
	rows, err := q.db.Query(ctx, listExecutions, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Execution{}
	for rows.Next() {
		var i Execution
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.WorkflowID,
			&i.TemporalWorkflowID,
			&i.TemporalRunID,
			&i.Status,
			&i.Input,
			&i.Output,
			&i.Error,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExecutionsByStatus = `-- name: ListExecutionsByStatus :many
SELECT id, tenant_id, workflow_id, temporal_workflow_id, temporal_run_id, status, input, output, error, started_at, completed_at, created_by, created_at FROM executions
WHERE tenant_id = $1 AND status = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListExecutionsByStatusParams struct {
	TenantID uuid.UUID `db:"tenant_id" json:"tenant_id"`
	Status   string    `db:"status" json:"status"`
	Limit    int32     `db:"limit" json:"limit"`
	Offset   int32     `db:"offset" json:"offset"`
}

func (q *Queries) ListExecutionsByStatus(ctx context.Context, arg ListExecutionsByStatusParams) ([]Execution, error) {
	rows, err := q.db.Query(ctx, listExecutionsByStatus,
		arg.TenantID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Execution{}
	for rows.Next() {
		var i Execution
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.WorkflowID,
			&i.TemporalWorkflowID,
			&i.TemporalRunID,
			&i.Status,
			&i.Input,
			&i.Output,
			&i.Error,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExecutionsByWorkflow = `-- name: ListExecutionsByWorkflow :many
SELECT id, tenant_id, workflow_id, temporal_workflow_id, temporal_run_id, status, input, output, error, started_at, completed_at, created_by, created_at FROM executions
WHERE workflow_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListExecutionsByWorkflowParams struct {
	WorkflowID uuid.UUID `db:"workflow_id" json:"workflow_id"`
	Limit      int32     `db:"limit" json:"limit"`
	Offset     int32     `db:"offset" json:"offset"`
}

func (q *Queries) ListExecutionsByWorkflow(ctx context.Context, arg ListExecutionsByWorkflowParams) ([]Execution, error) {
	rows, err := q.db.Query(ctx, listExecutionsByWorkflow, arg.WorkflowID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Execution{}
	for rows.Next() {
		var i Execution
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.WorkflowID,
			&i.TemporalWorkflowID,
			&i.TemporalRunID,
			&i.Status,
			&i.Input,
			&i.Output,
			&i.Error,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentExecutions = `-- name: ListRecentExecutions :many
SELECT id, tenant_id, workflow_id, temporal_workflow_id, temporal_run_id, status, input, output, error, started_at, completed_at, created_by, created_at FROM executions
WHERE tenant_id = $1 AND created_at > $2
ORDER BY created_at DESC
LIMIT $3
`

type ListRecentExecutionsParams struct {
	TenantID  uuid.UUID `db:"tenant_id" json:"tenant_id"`
	CreatedAt time.Time `db:"created_at" json:"created_at"`
	Limit     int32     `db:"limit" json:"limit"`
}

func (q *Queries) ListRecentExecutions(ctx context.Context, arg ListRecentExecutionsParams) ([]Execution, error) {
	rows, err := q.db.Query(ctx, listRecentExecutions, arg.TenantID, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Execution{}
	for rows.Next() {
		var i Execution
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.WorkflowID,
			&i.TemporalWorkflowID,
			&i.TemporalRunID,
			&i.Status,
			&i.Input,
			&i.Output,
			&i.Error,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateExecutionStatus = `-- name: UpdateExecutionStatus :one
UPDATE executions
SET status = $2, started_at = COALESCE(started_at, CASE WHEN $2 = 'running' THEN NOW() END)
WHERE id = $1
RETURNING id, tenant_id, workflow_id, temporal_workflow_id, temporal_run_id, status, input, output, error, started_at, completed_at, created_by, created_at
`

type UpdateExecutionStatusParams struct {
	ID     uuid.UUID `db:"id" json:"id"`
	Status string    `db:"status" json:"status"`
}

func (q *Queries) UpdateExecutionStatus(ctx context.Context, arg UpdateExecutionStatusParams) (Execution, error) {
	row := q.db.QueryRow(ctx, updateExecutionStatus, arg.ID, arg.Status)
	var i Execution
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.WorkflowID,
		&i.TemporalWorkflowID,
		&i.TemporalRunID,
		&i.Status,
		&i.Input,
		&i.Output,
		&i.Error,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const updateExecutionTemporalIDs = `-- name: UpdateExecutionTemporalIDs :exec
UPDATE executions
SET temporal_workflow_id = $2, temporal_run_id = $3
WHERE id = $1
`

type UpdateExecutionTemporalIDsParams struct {
	ID                 uuid.UUID `db:"id" json:"id"`
	TemporalWorkflowID *string   `db:"temporal_workflow_id" json:"temporal_workflow_id"`
	TemporalRunID      *string   `db:"temporal_run_id" json:"temporal_run_id"`
}

func (q *Queries) UpdateExecutionTemporalIDs(ctx context.Context, arg UpdateExecutionTemporalIDsParams) error {
	_, err := q.db.Exec(ctx, updateExecutionTemporalIDs, arg.ID, arg.TemporalWorkflowID, arg.TemporalRunID)
	return err
}
