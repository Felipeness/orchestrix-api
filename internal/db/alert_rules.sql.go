// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: alert_rules.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countAlertRules = `-- name: CountAlertRules :one
SELECT COUNT(*) FROM alert_rules
WHERE tenant_id = $1
`

func (q *Queries) CountAlertRules(ctx context.Context, tenantID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countAlertRules, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAlertRule = `-- name: CreateAlertRule :one
INSERT INTO alert_rules (
    tenant_id, name, description, enabled,
    condition_type, condition_config,
    severity, alert_title_template, alert_message_template,
    trigger_workflow_id, trigger_input_template,
    cooldown_seconds, created_by
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
RETURNING id, tenant_id, name, description, enabled, condition_type, condition_config, severity, alert_title_template, alert_message_template, trigger_workflow_id, trigger_input_template, cooldown_seconds, last_triggered_at, created_by, created_at, updated_at
`

type CreateAlertRuleParams struct {
	TenantID             uuid.UUID       `db:"tenant_id" json:"tenant_id"`
	Name                 string          `db:"name" json:"name"`
	Description          *string         `db:"description" json:"description"`
	Enabled              bool            `db:"enabled" json:"enabled"`
	ConditionType        string          `db:"condition_type" json:"condition_type"`
	ConditionConfig      json.RawMessage `db:"condition_config" json:"condition_config"`
	Severity             string          `db:"severity" json:"severity"`
	AlertTitleTemplate   string          `db:"alert_title_template" json:"alert_title_template"`
	AlertMessageTemplate *string         `db:"alert_message_template" json:"alert_message_template"`
	TriggerWorkflowID    pgtype.UUID     `db:"trigger_workflow_id" json:"trigger_workflow_id"`
	TriggerInputTemplate []byte          `db:"trigger_input_template" json:"trigger_input_template"`
	CooldownSeconds      int32           `db:"cooldown_seconds" json:"cooldown_seconds"`
	CreatedBy            pgtype.UUID     `db:"created_by" json:"created_by"`
}

func (q *Queries) CreateAlertRule(ctx context.Context, arg CreateAlertRuleParams) (AlertRule, error) {
	row := q.db.QueryRow(ctx, createAlertRule,
		arg.TenantID,
		arg.Name,
		arg.Description,
		arg.Enabled,
		arg.ConditionType,
		arg.ConditionConfig,
		arg.Severity,
		arg.AlertTitleTemplate,
		arg.AlertMessageTemplate,
		arg.TriggerWorkflowID,
		arg.TriggerInputTemplate,
		arg.CooldownSeconds,
		arg.CreatedBy,
	)
	var i AlertRule
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Description,
		&i.Enabled,
		&i.ConditionType,
		&i.ConditionConfig,
		&i.Severity,
		&i.AlertTitleTemplate,
		&i.AlertMessageTemplate,
		&i.TriggerWorkflowID,
		&i.TriggerInputTemplate,
		&i.CooldownSeconds,
		&i.LastTriggeredAt,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAlertRule = `-- name: DeleteAlertRule :exec
DELETE FROM alert_rules
WHERE id = $1 AND tenant_id = $2
`

type DeleteAlertRuleParams struct {
	ID       uuid.UUID `db:"id" json:"id"`
	TenantID uuid.UUID `db:"tenant_id" json:"tenant_id"`
}

func (q *Queries) DeleteAlertRule(ctx context.Context, arg DeleteAlertRuleParams) error {
	_, err := q.db.Exec(ctx, deleteAlertRule, arg.ID, arg.TenantID)
	return err
}

const getAlertRule = `-- name: GetAlertRule :one
SELECT id, tenant_id, name, description, enabled, condition_type, condition_config, severity, alert_title_template, alert_message_template, trigger_workflow_id, trigger_input_template, cooldown_seconds, last_triggered_at, created_by, created_at, updated_at FROM alert_rules
WHERE id = $1 AND tenant_id = $2
`

type GetAlertRuleParams struct {
	ID       uuid.UUID `db:"id" json:"id"`
	TenantID uuid.UUID `db:"tenant_id" json:"tenant_id"`
}

func (q *Queries) GetAlertRule(ctx context.Context, arg GetAlertRuleParams) (AlertRule, error) {
	row := q.db.QueryRow(ctx, getAlertRule, arg.ID, arg.TenantID)
	var i AlertRule
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Description,
		&i.Enabled,
		&i.ConditionType,
		&i.ConditionConfig,
		&i.Severity,
		&i.AlertTitleTemplate,
		&i.AlertMessageTemplate,
		&i.TriggerWorkflowID,
		&i.TriggerInputTemplate,
		&i.CooldownSeconds,
		&i.LastTriggeredAt,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAlertRulesForMetric = `-- name: GetAlertRulesForMetric :many
SELECT id, tenant_id, name, description, enabled, condition_type, condition_config, severity, alert_title_template, alert_message_template, trigger_workflow_id, trigger_input_template, cooldown_seconds, last_triggered_at, created_by, created_at, updated_at FROM alert_rules
WHERE tenant_id = $1
    AND enabled = true
    AND condition_type = 'metric_threshold'
    AND condition_config->>'metric_name' = $2
    AND (last_triggered_at IS NULL OR last_triggered_at < NOW() - (cooldown_seconds || ' seconds')::interval)
`

type GetAlertRulesForMetricParams struct {
	TenantID        uuid.UUID       `db:"tenant_id" json:"tenant_id"`
	ConditionConfig json.RawMessage `db:"condition_config" json:"condition_config"`
}

func (q *Queries) GetAlertRulesForMetric(ctx context.Context, arg GetAlertRulesForMetricParams) ([]AlertRule, error) {
	rows, err := q.db.Query(ctx, getAlertRulesForMetric, arg.TenantID, arg.ConditionConfig)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AlertRule{}
	for rows.Next() {
		var i AlertRule
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Description,
			&i.Enabled,
			&i.ConditionType,
			&i.ConditionConfig,
			&i.Severity,
			&i.AlertTitleTemplate,
			&i.AlertMessageTemplate,
			&i.TriggerWorkflowID,
			&i.TriggerInputTemplate,
			&i.CooldownSeconds,
			&i.LastTriggeredAt,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAlertRules = `-- name: ListAlertRules :many
SELECT id, tenant_id, name, description, enabled, condition_type, condition_config, severity, alert_title_template, alert_message_template, trigger_workflow_id, trigger_input_template, cooldown_seconds, last_triggered_at, created_by, created_at, updated_at FROM alert_rules
WHERE tenant_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListAlertRulesParams struct {
	TenantID uuid.UUID `db:"tenant_id" json:"tenant_id"`
	Limit    int32     `db:"limit" json:"limit"`
	Offset   int32     `db:"offset" json:"offset"`
}

func (q *Queries) ListAlertRules(ctx context.Context, arg ListAlertRulesParams) ([]AlertRule, error) {
	rows, err := q.db.Query(ctx, listAlertRules, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AlertRule{}
	for rows.Next() {
		var i AlertRule
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Description,
			&i.Enabled,
			&i.ConditionType,
			&i.ConditionConfig,
			&i.Severity,
			&i.AlertTitleTemplate,
			&i.AlertMessageTemplate,
			&i.TriggerWorkflowID,
			&i.TriggerInputTemplate,
			&i.CooldownSeconds,
			&i.LastTriggeredAt,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAlertRulesByConditionType = `-- name: ListAlertRulesByConditionType :many
SELECT id, tenant_id, name, description, enabled, condition_type, condition_config, severity, alert_title_template, alert_message_template, trigger_workflow_id, trigger_input_template, cooldown_seconds, last_triggered_at, created_by, created_at, updated_at FROM alert_rules
WHERE tenant_id = $1 AND condition_type = $2 AND enabled = true
`

type ListAlertRulesByConditionTypeParams struct {
	TenantID      uuid.UUID `db:"tenant_id" json:"tenant_id"`
	ConditionType string    `db:"condition_type" json:"condition_type"`
}

func (q *Queries) ListAlertRulesByConditionType(ctx context.Context, arg ListAlertRulesByConditionTypeParams) ([]AlertRule, error) {
	rows, err := q.db.Query(ctx, listAlertRulesByConditionType, arg.TenantID, arg.ConditionType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AlertRule{}
	for rows.Next() {
		var i AlertRule
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Description,
			&i.Enabled,
			&i.ConditionType,
			&i.ConditionConfig,
			&i.Severity,
			&i.AlertTitleTemplate,
			&i.AlertMessageTemplate,
			&i.TriggerWorkflowID,
			&i.TriggerInputTemplate,
			&i.CooldownSeconds,
			&i.LastTriggeredAt,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEnabledAlertRules = `-- name: ListEnabledAlertRules :many
SELECT id, tenant_id, name, description, enabled, condition_type, condition_config, severity, alert_title_template, alert_message_template, trigger_workflow_id, trigger_input_template, cooldown_seconds, last_triggered_at, created_by, created_at, updated_at FROM alert_rules
WHERE tenant_id = $1 AND enabled = true
ORDER BY name
`

func (q *Queries) ListEnabledAlertRules(ctx context.Context, tenantID uuid.UUID) ([]AlertRule, error) {
	rows, err := q.db.Query(ctx, listEnabledAlertRules, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AlertRule{}
	for rows.Next() {
		var i AlertRule
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Description,
			&i.Enabled,
			&i.ConditionType,
			&i.ConditionConfig,
			&i.Severity,
			&i.AlertTitleTemplate,
			&i.AlertMessageTemplate,
			&i.TriggerWorkflowID,
			&i.TriggerInputTemplate,
			&i.CooldownSeconds,
			&i.LastTriggeredAt,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAlertRule = `-- name: UpdateAlertRule :one
UPDATE alert_rules
SET
    name = COALESCE($3, name),
    description = COALESCE($4, description),
    enabled = COALESCE($5, enabled),
    condition_type = COALESCE($6, condition_type),
    condition_config = COALESCE($7, condition_config),
    severity = COALESCE($8, severity),
    alert_title_template = COALESCE($9, alert_title_template),
    alert_message_template = COALESCE($10, alert_message_template),
    trigger_workflow_id = $11,
    trigger_input_template = $12,
    cooldown_seconds = COALESCE($13, cooldown_seconds)
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, name, description, enabled, condition_type, condition_config, severity, alert_title_template, alert_message_template, trigger_workflow_id, trigger_input_template, cooldown_seconds, last_triggered_at, created_by, created_at, updated_at
`

type UpdateAlertRuleParams struct {
	ID                   uuid.UUID       `db:"id" json:"id"`
	TenantID             uuid.UUID       `db:"tenant_id" json:"tenant_id"`
	Name                 string          `db:"name" json:"name"`
	Description          *string         `db:"description" json:"description"`
	Enabled              bool            `db:"enabled" json:"enabled"`
	ConditionType        string          `db:"condition_type" json:"condition_type"`
	ConditionConfig      json.RawMessage `db:"condition_config" json:"condition_config"`
	Severity             string          `db:"severity" json:"severity"`
	AlertTitleTemplate   string          `db:"alert_title_template" json:"alert_title_template"`
	AlertMessageTemplate *string         `db:"alert_message_template" json:"alert_message_template"`
	TriggerWorkflowID    pgtype.UUID     `db:"trigger_workflow_id" json:"trigger_workflow_id"`
	TriggerInputTemplate []byte          `db:"trigger_input_template" json:"trigger_input_template"`
	CooldownSeconds      int32           `db:"cooldown_seconds" json:"cooldown_seconds"`
}

func (q *Queries) UpdateAlertRule(ctx context.Context, arg UpdateAlertRuleParams) (AlertRule, error) {
	row := q.db.QueryRow(ctx, updateAlertRule,
		arg.ID,
		arg.TenantID,
		arg.Name,
		arg.Description,
		arg.Enabled,
		arg.ConditionType,
		arg.ConditionConfig,
		arg.Severity,
		arg.AlertTitleTemplate,
		arg.AlertMessageTemplate,
		arg.TriggerWorkflowID,
		arg.TriggerInputTemplate,
		arg.CooldownSeconds,
	)
	var i AlertRule
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Description,
		&i.Enabled,
		&i.ConditionType,
		&i.ConditionConfig,
		&i.Severity,
		&i.AlertTitleTemplate,
		&i.AlertMessageTemplate,
		&i.TriggerWorkflowID,
		&i.TriggerInputTemplate,
		&i.CooldownSeconds,
		&i.LastTriggeredAt,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateAlertRuleLastTriggered = `-- name: UpdateAlertRuleLastTriggered :exec
UPDATE alert_rules
SET last_triggered_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateAlertRuleLastTriggered(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateAlertRuleLastTriggered, id)
	return err
}
