// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: workflows.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countWorkflows = `-- name: CountWorkflows :one
SELECT COUNT(*) FROM workflows WHERE tenant_id = $1
`

func (q *Queries) CountWorkflows(ctx context.Context, tenantID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countWorkflows, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countWorkflowsByStatus = `-- name: CountWorkflowsByStatus :one
SELECT COUNT(*) FROM workflows WHERE tenant_id = $1 AND status = $2
`

type CountWorkflowsByStatusParams struct {
	TenantID uuid.UUID `db:"tenant_id" json:"tenant_id"`
	Status   string    `db:"status" json:"status"`
}

func (q *Queries) CountWorkflowsByStatus(ctx context.Context, arg CountWorkflowsByStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, countWorkflowsByStatus, arg.TenantID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createWorkflow = `-- name: CreateWorkflow :one
INSERT INTO workflows (tenant_id, name, description, definition, schedule, status, created_by)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, tenant_id, name, description, definition, schedule, status, version, created_by, created_at, updated_at
`

type CreateWorkflowParams struct {
	TenantID    uuid.UUID       `db:"tenant_id" json:"tenant_id"`
	Name        string          `db:"name" json:"name"`
	Description *string         `db:"description" json:"description"`
	Definition  json.RawMessage `db:"definition" json:"definition"`
	Schedule    *string         `db:"schedule" json:"schedule"`
	Status      string          `db:"status" json:"status"`
	CreatedBy   pgtype.UUID     `db:"created_by" json:"created_by"`
}

func (q *Queries) CreateWorkflow(ctx context.Context, arg CreateWorkflowParams) (Workflow, error) {
	row := q.db.QueryRow(ctx, createWorkflow,
		arg.TenantID,
		arg.Name,
		arg.Description,
		arg.Definition,
		arg.Schedule,
		arg.Status,
		arg.CreatedBy,
	)
	var i Workflow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Description,
		&i.Definition,
		&i.Schedule,
		&i.Status,
		&i.Version,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteWorkflow = `-- name: DeleteWorkflow :exec
DELETE FROM workflows WHERE id = $1
`

func (q *Queries) DeleteWorkflow(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteWorkflow, id)
	return err
}

const getScheduledWorkflows = `-- name: GetScheduledWorkflows :many
SELECT id, tenant_id, name, description, definition, schedule, status, version, created_by, created_at, updated_at FROM workflows
WHERE status = 'active' AND schedule IS NOT NULL
ORDER BY created_at
`

func (q *Queries) GetScheduledWorkflows(ctx context.Context) ([]Workflow, error) {
	rows, err := q.db.Query(ctx, getScheduledWorkflows)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Workflow{}
	for rows.Next() {
		var i Workflow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Description,
			&i.Definition,
			&i.Schedule,
			&i.Status,
			&i.Version,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkflow = `-- name: GetWorkflow :one
SELECT id, tenant_id, name, description, definition, schedule, status, version, created_by, created_at, updated_at FROM workflows WHERE id = $1
`

func (q *Queries) GetWorkflow(ctx context.Context, id uuid.UUID) (Workflow, error) {
	row := q.db.QueryRow(ctx, getWorkflow, id)
	var i Workflow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Description,
		&i.Definition,
		&i.Schedule,
		&i.Status,
		&i.Version,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listWorkflows = `-- name: ListWorkflows :many
SELECT id, tenant_id, name, description, definition, schedule, status, version, created_by, created_at, updated_at FROM workflows
WHERE tenant_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListWorkflowsParams struct {
	TenantID uuid.UUID `db:"tenant_id" json:"tenant_id"`
	Limit    int32     `db:"limit" json:"limit"`
	Offset   int32     `db:"offset" json:"offset"`
}

func (q *Queries) ListWorkflows(ctx context.Context, arg ListWorkflowsParams) ([]Workflow, error) {
	rows, err := q.db.Query(ctx, listWorkflows, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Workflow{}
	for rows.Next() {
		var i Workflow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Description,
			&i.Definition,
			&i.Schedule,
			&i.Status,
			&i.Version,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkflowsByStatus = `-- name: ListWorkflowsByStatus :many
SELECT id, tenant_id, name, description, definition, schedule, status, version, created_by, created_at, updated_at FROM workflows
WHERE tenant_id = $1 AND status = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListWorkflowsByStatusParams struct {
	TenantID uuid.UUID `db:"tenant_id" json:"tenant_id"`
	Status   string    `db:"status" json:"status"`
	Limit    int32     `db:"limit" json:"limit"`
	Offset   int32     `db:"offset" json:"offset"`
}

func (q *Queries) ListWorkflowsByStatus(ctx context.Context, arg ListWorkflowsByStatusParams) ([]Workflow, error) {
	rows, err := q.db.Query(ctx, listWorkflowsByStatus,
		arg.TenantID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Workflow{}
	for rows.Next() {
		var i Workflow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Description,
			&i.Definition,
			&i.Schedule,
			&i.Status,
			&i.Version,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWorkflow = `-- name: UpdateWorkflow :one
UPDATE workflows
SET name = $2, description = $3, definition = $4, schedule = $5, status = $6, version = version + 1
WHERE id = $1
RETURNING id, tenant_id, name, description, definition, schedule, status, version, created_by, created_at, updated_at
`

type UpdateWorkflowParams struct {
	ID          uuid.UUID       `db:"id" json:"id"`
	Name        string          `db:"name" json:"name"`
	Description *string         `db:"description" json:"description"`
	Definition  json.RawMessage `db:"definition" json:"definition"`
	Schedule    *string         `db:"schedule" json:"schedule"`
	Status      string          `db:"status" json:"status"`
}

func (q *Queries) UpdateWorkflow(ctx context.Context, arg UpdateWorkflowParams) (Workflow, error) {
	row := q.db.QueryRow(ctx, updateWorkflow,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Definition,
		arg.Schedule,
		arg.Status,
	)
	var i Workflow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Description,
		&i.Definition,
		&i.Schedule,
		&i.Status,
		&i.Version,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateWorkflowStatus = `-- name: UpdateWorkflowStatus :one
UPDATE workflows
SET status = $2
WHERE id = $1
RETURNING id, tenant_id, name, description, definition, schedule, status, version, created_by, created_at, updated_at
`

type UpdateWorkflowStatusParams struct {
	ID     uuid.UUID `db:"id" json:"id"`
	Status string    `db:"status" json:"status"`
}

func (q *Queries) UpdateWorkflowStatus(ctx context.Context, arg UpdateWorkflowStatusParams) (Workflow, error) {
	row := q.db.QueryRow(ctx, updateWorkflowStatus, arg.ID, arg.Status)
	var i Workflow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Description,
		&i.Definition,
		&i.Schedule,
		&i.Status,
		&i.Version,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
